#' Make connection plotdata
#'
#' @param milestone_network The milestone network
#' @param orientation The orientation of the onedim between milestones
#' @param margin Relative distance between milestones
#'
#' @importFrom dynutils extract_row_to_list
#'
#' @export
make_connection_plotdata <- function(milestone_network, orientation = 1, margin=0.05) {
  allmilestones <- unique(c(milestone_network$from, milestone_network$to))

  margin <- sum(milestone_network$length) * margin

  # these four objects will remember the from and to positions and levels for every milestone, to be used for onedim
  milestone_from_poss <- map(allmilestones, ~list()) %>% set_names(allmilestones)
  milestone_to_poss <- map(allmilestones, ~list()) %>% set_names(allmilestones)

  milestone_from_levels <- map(allmilestones, ~list()) %>% set_names(allmilestones)
  milestone_to_levels <- map(allmilestones, ~list()) %>% set_names(allmilestones)

  states <- tibble(from_pos=numeric(), to_pos=numeric(),  level=integer(), edge_id=integer(), from=character(), to=character())
  onedim <- tibble(from_pos=numeric(), to_pos=numeric(),  level=integer(), edge_id=integer(), from_level=integer(), to_level=integer())

  last_edge_to_pos <- 0

  for (edge_id in seq_len(nrow(milestone_network))) {
    edge <- dynutils::extract_row_to_list(milestone_network, edge_id)

    # STATE EDGE --------------------------------
    edge_from_pos <- if(last_edge_to_pos == 0) 0 else last_edge_to_pos + margin
    edge_to_pos <- edge_from_pos + edge$length
    last_edge_to_pos <- edge_to_pos

    level <- 0

    states <- states %>% add_row(from_pos=edge_from_pos, to_pos=edge_to_pos, level=0, edge_id=edge_id, from=edge$from, to=edge$to)

    ## onedim EDGE(S) -----------------------
    # add positions of these milestones
    milestone_from_poss[[edge$from]] <- c(milestone_from_poss[[edge$from]], edge_from_pos)
    milestone_from_levels[[edge$from]] <- c(milestone_from_levels[[edge$from]], level)

    milestone_to_poss[[edge$to]] <-  c(milestone_to_poss[[edge$to]], edge_to_pos)
    milestone_to_levels[[edge$to]] %<>% c(milestone_to_levels[[edge$to]], level)

    ## CONNECTION FROM FROM
    for (i in seq_along(milestone_to_poss[[edge$from]])) {
      onedim <- add_connection(
        connection_from_pos = milestone_to_poss[[edge$from]][[i]],
        connection_to_pos = edge_from_pos,
        connection_from_level = milestone_to_levels[[edge$from]][[i]],
        connection_to_level = level,
        onedim = onedim,
        edge_id = edge_id,
        margin = margin
      )
    }

    ## CONNECTION FROM TO
    for (i in seq_along(milestone_from_poss[[edge$to]])) {
      onedim <- add_connection(
        connection_from_pos = edge_to_pos,
        connection_to_pos = milestone_from_poss[[edge$to]][[i]],
        connection_from_level = level,
        connection_to_level = milestone_from_levels[[edge$to]][[i]],
        onedim = onedim,
        edge_id = edge_id,
        margin = margin
      )
    }
  }

  all_edge_ids <- states$edge_id
  states$edge_id <- factor(states$edge_id, levels=all_edge_ids)
  onedim$edge_id <- factor(onedim$edge_id, levels=all_edge_ids)

  tibble::lst(states, onedim)
}

#' Plot onedim
#'
#' @param task A trajectory or milestone_network
#' @param milestone_network Optional, the milestone network
#' @param plotdata Optional, The plotting data as generated by make_connection_plotdata
#'
#' @export
#' @inheritParams make_connection_plotdata
#' @inheritParams add_cell_coloring
#'
#' @importFrom ggrepel geom_label_repel
plot_onedim <- function(
  task = NULL,
  color_cells,
  milestone_network = task$milestone_network,
  grouping_assignment,
  groups,
  gene_oi,
  pseudotime,
  expression_source,
  color_milestones,
  milestones,
  orientation = 1,
  margin = 0.05,
  plotdata = make_connection_plotdata(milestone_network, orientation = orientation, margin = margin)
) {
  # root if necessary
  if ("root_milestone_id" %in% names(task)) {
    root <- task$root_milestone_id
  } else {
    task <- dynwrap::root_trajectory(task, start_milestone_id = task$milestone_ids[[1]])
    root <- task$root_milestone_id
  }

  # make sure every cell is on only one edge
  task$progressions <- progressions_one_edge(task$progressions)

  # cell positions
  cell_positions <- task$progressions %>%
    left_join(plotdata$states, by=c("from", "to")) %>%
    mutate(x = from_pos + (to_pos - from_pos) * percentage, y=0) %>%
    mutate(y = y + vipor::offsetX(x, edge_id, method="quasirandom", width=0.2))

  # add cell coloring
  cell_coloring_output <- do.call(add_cell_coloring, map(names(formals(add_cell_coloring)), get, envir=environment()))
  cell_positions <- cell_coloring_output$cell_positions
  fill_scale <- cell_coloring_output$fill_scale

  # get x limit
  max_limit <- if(nrow(plotdata$onedim)) {max(plotdata$onedim$level)} else {0}

  plot <- ggplot() +
    geom_segment(aes(from_pos, level, xend=to_pos, yend=level), data=plotdata$onedim, linetype="dotted", color="#444444") +
    geom_segment(aes(to_pos, level, xend=to_pos+0.0001, yend=to_level), data=plotdata$onedim, linetype="dotted", color="#444444") +
    geom_segment(aes(from_pos, level, xend=to_pos, yend=level), data=plotdata$states, color="black") +
    geom_segment(aes(from_pos, from_level, xend=from_pos, yend=level), data=plotdata$onedim, linetype="dotted", color="#444444") +
    geom_point(aes(from_pos, level), data=plotdata$states %>% filter(from == first(from)), color="black") +
    geom_point(aes(to_pos, level), data=plotdata$states %>% filter(!(to %in% from)), shape=15, color="black") +
    # the cells
    geom_point(aes(x, y, fill=color), data=cell_positions, shape=21, color="#33333388") +
    fill_scale +
    theme_graph() +
    theme(legend.position="bottom")

  # if (!is.null(cell_progressions)) {
  #   plot <- plot + ggrepel::geom_label_repel(aes(position, 0, label=cell_id, fill = color), data=cell_positions, direction="x", nudge_y=-orientation, min.segment.length=0) + scale_fill_identity()
  #   min_limit <- -1
  # } else {
    min_limit <- -0.2
  # }

  if(orientation == -1) {
    plot <- plot + scale_y_reverse(expand=c(0.1, 0), limits=c(max_limit+0.5, min_limit))
  } else {
    plot <- plot + scale_y_continuous(expand=c(0.1, 0), limits=c(min_limit, max_limit+0.5))
  }

  plot
}

add_connection <- function(connection_from_pos, connection_to_pos, connection_from_level, connection_to_level, onedim, edge_id, margin) {
  max_bound <- max(connection_from_pos, connection_to_pos)
  min_bound <- min(connection_from_pos, connection_to_pos)

  if (nrow(onedim) > 0) {
    available_levels <- onedim %>%
      group_by(level) %>%
      summarise(
        available = all((pmax(from_pos, to_pos) < min_bound) | (pmin(from_pos, to_pos) > max_bound))
      ) %>%
      filter(available) %>%
      pull(level)
  } else {
    available_levels <- c(1)
  }

  available_levels <- c(0, available_levels)

  # avoid that onedim can go through states
  # check whether the distance is equal to the margin ==> direct level-0 onedim are allowed
  if (abs(abs(connection_from_pos - connection_to_pos) - margin) > 0.0001) {
    available_levels <- available_levels[available_levels != connection_from_level]
  }

  if(length(available_levels) > 0) {
    level <- min(available_levels)
  } else {
    level <- max(onedim$level) + 1
  }

  onedim <- onedim %>% add_row(
    from_pos = connection_from_pos,
    to_pos = connection_to_pos,
    from_level = connection_from_level,
    to_level = connection_to_level,
    level = level,
    edge_id = edge_id
  )

  onedim
}
