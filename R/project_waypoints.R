#' Project the waypoints
#'
#' @inheritParams add_cell_coloring
#' @param waypoints The waypoints to use for projecting, as generated by [dynwrap::select_waypoints()]
#' @param trajectory_projection_sd The standard deviation of the gaussian kernel
#' @param color_trajectory How to color the trajectory, can be "nearest" for coloring to nearest cell, or "none"
#' @param edge_positions The positions of the edges
#'
#' @importFrom stats dnorm approx
project_waypoints_coloured <- function(
  trajectory,
  cell_positions,
  edge_positions = NULL,
  waypoints = dynwrap::select_waypoints(trajectory),
  trajectory_projection_sd = sum(trajectory$milestone_network$length) * 0.05,
  color_trajectory = "none"
) {
  waypoints$waypoint_network <- waypoints$waypoint_network %>%
    rename(
      milestone_id_from = from_milestone_id,
      milestone_id_to = to_milestone_id
    )

  assert_that(color_trajectory %in% c("nearest", "none"))
  assert_that(setequal(cell_positions$cell_id, colnames(waypoints$geodesic_distances)))

  # project waypoints to dimensionality reduction using kernel and geodesic distances
  # rate <- 5
  # trajectory_projection_sd <- sum(trajectory$milestone_network$length) * 0.05
  # dist_cutoff <- sum(milestone_network$length) * 0.05
  # k <- 3
  # weight_cutoff <- 0.01

  # weights <- waypoints$geodesic_distances %>% stats::dexp(rate = 5)
  weights <- waypoints$geodesic_distances %>% stats::dnorm(sd = trajectory_projection_sd)
  assert_that(all(!is.na(weights)))
  # weights <- waypoints$geodesic_distances < dist_cutoff
  # weights[weights < weight_cutoff] <- 0

  weights <- weights / rowSums(weights)
  positions <- cell_positions %>%
    select(cell_id, comp_1, comp_2) %>%
    slice(match(colnames(weights), cell_id)) %>%
    column_to_rownames("cell_id") %>%
    as.matrix()

  # make sure weights and positions have the same cell_ids in the same order
  assert_that(all.equal(colnames(weights), rownames(positions)))

  # calculate positions
  matrix_to_tibble <- function(x, rownames_column) {y <- as_tibble(x);y[[rownames_column]] <- rownames(x);y}
  if (!is.null(edge_positions)) {
    comp_names <- colnames(edge_positions) %>% keep(~grepl("comp_", .))
    waypoint_positions <-
      waypoints$progressions %>%
      group_by(from, to) %>%
      do({
        df <- .
        rel_edge_pos <- edge_positions %>% filter(from == df$from[[1]], to == df$to[[1]])
        for (cn in comp_names) {
          df[[cn]] <- approx(rel_edge_pos$percentage, rel_edge_pos[[cn]], df$percentage)$y
        }
        df
      }) %>%
      ungroup() %>%
      select(!!comp_names, waypoint_id) %>%
      left_join(waypoints$waypoints, "waypoint_id")
  } else {
    waypoint_positions <- (weights %*% positions) %>%
      matrix_to_tibble("waypoint_id") %>%
      left_join(waypoints$waypoints, "waypoint_id")
  }


  # add color of closest cell
  if (color_trajectory == "nearest") {
    assert_that("color" %in% colnames(cell_positions))

    cpv <- cell_positions %>% select(cell_id, color) %>% deframe()
    waypoint_positions <- waypoint_positions %>%
      mutate(
        closest_cell_ix = (weights %>% apply(1, which.max))[waypoint_id],
        closest_cell_id = colnames(weights)[closest_cell_ix],
        color = cpv[closest_cell_id]
      )
  }

  segments <- left_join(
    waypoint_positions,
    waypoints$progressions,
    by = "waypoint_id"
  ) %>%
    mutate(group = factor(paste0(from, "---", to))) %>%
    group_by(group) %>%
    mutate(
      closest = which.min(abs(percentage - 0.5)),
      arrow = row_number() == closest | row_number() - 1 == closest
    ) %>%
    ungroup() %>%
    select(-closest)

  lst(
    segments = segments
  )
}
