#' Perform dimensionality reduction on a trajectory and the respective samples in order to plot it
#'
#' @param traj A trajectory as generated by
#'  \code{\link[dynwrap]{wrap_data}} and \code{\link[dynwrap]{add_trajectory_to_wrapper}}.
#' @param colour_cells How to colour the cells. Must be equal to \code{"milestone"}
#'   or a custom character vector of colours, one for each cell.
#' @param colour_milestones How to color the milestones.
#'   Must be one of \code{"auto"} (default), \code{"Set3"}, \code{"rainbow"}, \code{"cubeHelix"},
#'   or a custom character vector of colours, one for each milestone.
#'
#' @importFrom igraph graph_from_data_frame layout_with_kk
#' @importFrom testthat expect_true
#' @importFrom grDevices col2rgb rgb colorRampPalette
#' @importFrom RColorBrewer brewer.pal
#'
#' @export
dimred_trajectory <- function(
  traj,
  colour_cells = "milestone",
  colour_milestones = "auto"
) {
  # expect traj to contain a trajectory
  testthat::expect_true(is_data_wrapper(traj))
  testthat::expect_true(is_wrapper_with_trajectory(traj))

  # retrieve some objects to work with
  name <- traj$id
  cell_ids <- traj$cell_ids
  milestone_ids <- traj$milestone_ids
  num_milestones <- length(milestone_ids)
  milestone_network <- traj$milestone_network %>%
    filter(to != "FILTERED_CELLS")
  milestone_percentages <- traj$milestone_percentages
  is_directed <- any(traj$milestone_network$directed)

  # check colour_milestones
  colour_milestones_auto <- length(colour_milestones) == 1 && colour_milestones %in% names(milestone_palette_list)
  colour_milestones_given <- all(milestone_ids %in% names(colour_milestones)) && is_colour_vector(colour_milestones)

  # determine milestone colours
  col_milest_hex <-
    if (colour_milestones_auto) {
      set_names(milestone_palette(colour_milestones, n = length(milestone_ids)), milestone_ids)
    } else if (colour_milestones_given) {
      colour_milestones
    } else {
      stop(
        sQuote("colour_milestones"),
        " must be either one of ", paste(sQuote(names(milestone_palette_list)), collapse = ", "),
        " or must be a named character vector of colours."
      )
    }
  col_milest_rgb <- t(col2rgb(col_milest_hex))

  # check colour_cells
  colour_cells_auto <- length(colour_cells) == 1 && colour_cells %in% c("milestone")
  colour_cells_expression <- is_wrapper_with_expression(traj) && length(colour_cells) == 1 && colour_cells %in% colnames(traj$expression)
  colour_cells_given <- all(cell_ids %in% names(colour_cells)) && is_colour_vector(colour_cells)
  colour_cells_given_numeric <- all(cell_ids %in% names(colour_cells)) && is.numeric(colour_cells)

  if (colour_cells_expression) {
    colour_cells_given_numeric <- TRUE
    colour_cells <- traj$expression[,colour_cells]
  }

  # determine colour for cells
  col_cell_hex <-
    if (colour_cells_auto) {
      mix_colours <- function(milid, milpct) {
        colour_rgb <- apply(col_milest_rgb[milid,,drop=FALSE], 2, function(x) sum(x * milpct))
        colour_rgb[colour_rgb < 0] <- 0
        colour_rgb[colour_rgb > 256] <- 256
        do.call(rgb, as.list(c(colour_rgb, maxColorValue = 256)))
      }
      milestone_percentages %>%
        group_by(cell_id) %>%
        summarise(colour = mix_colours(milestone_id, percentage)) %$%
        set_names(colour, cell_id)
    } else if (colour_cells_given_numeric) {
      pal <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(11, "RdBu"))(100)
      pal[cut(colour_cells, breaks = 100, labels = FALSE)] %>%
        set_names(names(colour_cells))
    } else if (colour_cells_given) {
      colour_cells
    } else {
      stop(
        sQuote("colour_cells"),
        " must be either ", sQuote("milestone"),
        " or must be a named character vector of colours."
      )
    }

  # add phantom links, ifneedbe
  if (is_directed) {
    structure <- add_phantom_edges(milestone_ids, milestone_network)
  } else {
    structure <- milestone_network
  }

  # adjust weights on structure to make it easier to plot
  if (min(structure$length) * 3 < max(structure$length)) {
    structure <- structure %>% mutate(
      length = sqrt(dynutils::scale_minmax(length) + .5)
    )
  }

  # reduce dimensionality on milestone_network
  gr <- igraph::graph_from_data_frame(structure %>% rename(weight = length), vertices = milestone_ids)
  layout <-
    if (length(igraph::V(gr)) > 2) {
      igraph::layout_with_kk(gr, maxiter = 200)
    } else {
      igraph::layout.auto(gr)
    }
  layout <- layout %>%
    dynutils::scale_uniform() %>%
    set_rownames(milestone_ids) %>%
    set_colnames(paste0("Comp", seq_len(ncol(.))))
  space_milest_df <- layout %>%
    as.data.frame() %>%
    rownames_to_column()

  # project dimensionality to samples
  mix_dimred <- function(milid, milpct) {
    apply(layout[milid,,drop=FALSE], 2, function(x) sum(x * milpct)) %>% t %>% as_data_frame
  }

  # create output for samples
  space_samples <- milestone_percentages %>%
    group_by(cell_id) %>%
    do(mix_dimred(.$milestone_id, .$percentage)) %>%
    ungroup %>%
    slice(match(cell_ids, cell_id)) %>%
    mutate(name, colour = col_cell_hex[cell_id])

  # create output for milestones
  space_milestones <- space_milest_df %>%
    rename(milestone_id = rowname) %>%
    mutate(
      name,
      colour = col_milest_hex[milestone_ids]
    )

  # create output for edges between milestones
  space_lines <- milestone_network %>%
    mutate(name) %>%
    left_join(space_milest_df %>% select(from = rowname, from.Comp1 = Comp1, from.Comp2 = Comp2), by = "from") %>%
    left_join(space_milest_df %>% select(to = rowname, to.Comp1 = Comp1, to.Comp2 = Comp2), by = "to")

  # return all output
  l <- lst(
    id = traj$id,
    space_milestones = space_milestones,
    space_lines = space_lines,
    space_samples = space_samples
  )
  class(l) <- c("dynplot::ti_dimred_wrapper", "list")
  l
}

#' Perform dimred trajectory if needed
#' @param object An object generated by \code{wrap_data} or \code{dimred_trajectory}.
#' @inheritParams dimred_trajectory
check_or_perform_dimred <- inherit_default_params(
  list(dimred_trajectory),
  function(
    object,
    colour_cells,
    colour_milestones
  ) {
    if (is_data_wrapper(object) && is_wrapper_with_trajectory(object)) {
      dimred_object <- dimred_trajectory(
        object,
        colour_cells = colour_cells,
        colour_milestones = colour_milestones
      )
    } else if (is_ti_dimred_wrapper(object)) {
      dimred_object <- object
    } else {
      stop(sQuote("object"), " is not an object as generated by wrap_data or dimred_trajectory")
    }
    dimred_object
  }
)

is_ti_dimred_wrapper <- function(object) {
  "dynplot::ti_dimred_wrapper" %in% class(object)
}

# This is solely used to create spacing between nodes in dimred_trajectory

#' @importFrom reshape2 melt
#' @importFrom igraph graph_from_data_frame neighbors
add_phantom_edges <- function(milestone_ids, milestone_network) {
  is_directed <- any(milestone_network$directed)

  if (is_directed) {
    phantom_links1 <- bind_rows(lapply(milestone_ids, function(x) {
      strx <- milestone_network %>%
        filter(from == x)

      if (nrow(strx) > 1) {
        strx <- strx %>%
          mutate(
            angle = seq(0, 120/360*pi*2, length.out = n()),
            x = length * cos(angle),
            y = length * sin(angle)
          )
        poss <- strx %>% select(x, y) %>% as.matrix
        rownames(poss) <- strx$to
        poss %>%
          dist %>%
          as.matrix %>%
          reshape2::melt(varnames = c("from", "to"), value.name = "length") %>%
          mutate(from = as.character(from), to = as.character(to), directed = is_directed) %>%
          filter(from != to)
      } else {
        NULL
      }
    }))
    phantom_links2 <- bind_rows(lapply(milestone_ids, function(x) {
      strx <- milestone_network %>%
        filter(to == x)

      if (nrow(strx) > 1) {
        strx <- strx %>%
          mutate(
            angle = seq(0, 120/360*pi*2, length.out = n()),
            x = length * cos(angle),
            y = length * sin(angle)
          )
        poss <- strx %>% select(x, y) %>% as.matrix
        rownames(poss) <- strx$from
        poss %>%
          dist %>%
          as.matrix %>%
          reshape2::melt(varnames = c("from", "to"), value.name = "length") %>%
          mutate(from = as.character(from), to = as.character(to), directed = is_directed) %>%
          filter(from != to)
      } else {
        NULL
      }
    }))

    bind_rows(milestone_network, phantom_links1, phantom_links2)
  } else {
    gr <- igraph::graph_from_data_frame(milestone_network, directed = is_directed, vertices = milestone_ids)

    phantom_links <- bind_rows(lapply(milestone_ids, function(x) {
      neighs <- igraph::neighbors(gr, x) %>% names()
      strx <- milestone_network %>%
        filter((to == x & from %in% neighs) | (from == x & to %in% neighs))

      if (nrow(strx) > 1) {
        strx <- strx %>%
          mutate(
            angle = seq(0, 120/360*pi*2, length.out = n()),
            x = length * cos(angle),
            y = length * sin(angle)
          )
        poss <- strx %>% select(x, y) %>% as.matrix
        rownames(poss) <- neighs
        poss %>%
          dist %>%
          as.matrix %>%
          reshape2::melt(varnames = c("from", "to"), value.name = "length") %>%
          mutate(from = as.character(from), to = as.character(to), directed = is_directed) %>%
          filter(from != to)
      } else {
        NULL
      }
    }))

    bind_rows(milestone_network, phantom_links)
  }
}
