#' Project the waypoints
#' @inheritParams add_cell_coloring
#' @param waypoints The waypoints to use for projecting, as generated by [dynwrap::select_waypoints()]
#' @param trajectory_projection_sd The standard deviation of the gaussian kernel
#' @param n_arrows Number of arrows to add to trajectory projection
project_waypoints <- function(
  traj,
  cell_positions,
  waypoints = dynwrap::select_waypoints(traj),
  trajectory_projection_sd = sum(traj$milestone_network$length) * 0.05,
  n_arrows = 10
) {
  testthat::expect_setequal(cell_positions$cell_id, colnames(waypoints$geodesic_distances))

  # project waypoints to dimensionality reduction using kernel and geodesic distances
  # rate <- 5
  # trajectory_projection_sd <- sum(traj$milestone_network$length) * 0.05
  # dist_cutoff <- sum(milestone_network$length) * 0.05
  # k <- 3
  # weight_cutoff <- 0.01

  # weights <- waypoints$geodesic_distances %>% dexp(rate=rate)
  weights <- waypoints$geodesic_distances %>% dnorm(sd = trajectory_projection_sd)
  # weights <- waypoints$geodesic_distances < dist_cutoff
  # weights[weights < weight_cutoff] <- 0

  weights <- weights / rowSums(weights)
  positions <- cell_positions %>%
    select(cell_id, comp_1, comp_2) %>%
    slice(match(colnames(weights), cell_id)) %>%
    column_to_rownames("cell_id") %>%
    as.matrix()

  waypoint_positions <- (weights %*% positions) %>%
    as.data.frame() %>%
    rownames_to_column("waypoint_id") %>%
    left_join(waypoints$waypoints, "waypoint_id")

  # positions of different edges
  waypoint_edges <- waypoints$waypoint_network %>%
    left_join(waypoint_positions %>% rename_if(is.numeric, ~paste0(., "_from")), c("from"="waypoint_id")) %>%
    left_join(waypoint_positions %>% rename_if(is.numeric, ~paste0(., "_to")), c("to"="waypoint_id")) %>%
    mutate(length = sqrt((comp_1_to - comp_1_from)**2 + (comp_2_to - comp_2_from)**2))

  # add evenly distributed arrows
  waypoint_edges <- waypoint_edges %>%
    mutate(arrow = dplyr::row_number() %% round(n()/n_arrows) == 0)

  lst(
    positions = waypoint_positions,
    edges = waypoint_edges
  )
}




#' Plot the trajectory on dimensionality reduction
#'
#' @param expression_source Source of the expression
#' @param plot_milestone_network Whether to plot the projected milestone network on the dimensionality reduction
#' @param plot_trajectory Whether to plot the projected trajectory on the dimensionality reduction
#' @param trajectory_projection_sd The standard deviation of the gaussian kernel to be used for projecting the trajectory.
#'   This is in the order of maginature as the lengths of the milestone_network.
#'   The lower, the more closely the trajectory will follow the cells
#'
#' @inheritParams add_cell_coloring
#' @inheritParams add_milestone_coloring
#' @inheritParams add_density_coloring
#' @inheritParams dynwrap::get_milestone_labelling
#' @inheritParams dynwrap::get_dimred
#' @inheritParams project_waypoints
#'
#' @export
plot_dimred <- dynutils::inherit_default_params(
  list(
    add_cell_coloring,
    add_milestone_coloring,
    add_density_coloring,
    project_waypoints
  ),
  function(
    traj,
    color_cells,
    dimred = ifelse(dynwrap::is_wrapper_with_dimred(traj), NA, ifelse(length(traj$cell_ids) > 500, dimred_pca, dimred_mds)),
    plot_trajectory = dynwrap::is_wrapper_with_trajectory(traj) && !plot_milestone_network,
    plot_milestone_network = FALSE,
    label_milestones = dynwrap::is_wrapper_with_milestone_labelling(traj),

    # trajectory information
    grouping,
    groups,
    feature_oi,
    color_milestones,
    milestones,
    milestone_percentages,
    pseudotime,
    expression_source = "expression",

    # density params
    color_density = NULL,
    padding,
    nbins,
    bw,
    density_cutoff,
    density_cutoff_label,

    # plot trajectory params
    trajectory_projection_sd,
    n_arrows
  ) {
    color_cells <- match.arg(color_cells)

    dimred <- get_dimred(
      data_wrapper = traj,
      dimred = dimred,
      expression_source = expression_source
    )

    # get cell positions
    cell_positions <- dimred %>% as.data.frame() %>% rownames_to_column("cell_id")

    # assign cells to closest milestone
    cell_positions <- left_join(
      cell_positions,
      traj$milestone_percentages %>% group_by(cell_id) %>% arrange(desc(percentage)) %>% filter(dplyr::row_number() == 1) %>% select(cell_id, milestone_id),
      "cell_id"
    )

    # add milestone colors if necessary
    if ((plot_milestone_network || plot_trajectory) && color_cells == "milestone") {
      if(is.null(milestones)) {
        milestones <- add_milestone_coloring(tibble(milestone_id = traj$milestone_ids), color_milestones)
      }
    }

    cell_coloring_output <- do.call(add_cell_coloring, map(names(formals(add_cell_coloring)), get, envir=environment()))

    cell_positions <- cell_coloring_output$cell_positions
    color_scale <- cell_coloring_output$color_scale

    # calculate density
    if (!is.null(color_density)) {
      density_plots <- do.call(add_density_coloring, map(names(formals(add_density_coloring)), get, envir=environment()))
    } else {
      density_plots <- list()
    }

    # base plot without cells
    plot <- ggplot(cell_positions, aes(comp_1, comp_2)) +
      theme_graph() +
      theme(legend.position="bottom")

    # add density polygon
    if (!is.null(density_plots$polygon))
      plot <- plot + density_plots$polygon
    if (!is.null(density_plots$scale))
      plot <- plot + density_plots$scale

    # add cells
    plot <- plot +
      geom_point(size=2.5, color="black") +
      geom_point(aes(color=color), size=2) +
      color_scale

    # add milestone network if requested
    if (plot_milestone_network) {
      # calculate position of milestones
      milestone_positions <- cell_positions %>%
        group_by(milestone_id) %>%
        summarise_at(c("comp_1", "comp_2"), mean)

      # add missing groups (if no cells were added)
      milestone_positions <- bind_rows(
        map_df(
          setdiff(traj$milestone_ids, milestone_positions$milestone_id),
          function(milestone_id) {
            close_milestone_ids <-
              c(
                traj$milestone_network %>%
                  filter(from == milestone_id) %>%
                  pull(to),
                traj$milestone_network %>%
                  filter(to == milestone_id) %>%
                  pull(from) %>%
                  rep(3)
              )


            milestone_positions %>%
              slice(match(close_milestone_ids, milestone_id)) %>%
              summarise_at(c("comp_1", "comp_2"), mean) %>%
              mutate(milestone_id = !!milestone_id)
          }),
        milestone_positions
      )

      # get milestone network
      milestone_network <- traj$milestone_network %>%
        left_join(
          milestone_positions %>% rename_all(~paste0(., "_from")),
          by=c("from" = "milestone_id_from")
        ) %>%
        left_join(
          milestone_positions %>% rename_all(~paste0(., "_to")),
          by=c("to" = "milestone_id_to")
        ) %>%
        mutate(
          comp_1_mid = comp_1_from + (comp_1_to - comp_1_from) /2,
          comp_2_mid = comp_2_from + (comp_2_to - comp_2_from) /2
        )

      plot <- plot +
        ggraph::geom_edge_link(aes(x=comp_1_from, y=comp_2_from, xend=comp_1_to, yend=comp_2_to), data=milestone_network) +
        ggraph::geom_edge_link(aes(x=comp_1_from, y=comp_2_from, xend=comp_1_mid, yend=comp_2_mid), data=milestone_network, arrow=arrow(type="closed", length = unit(0.4, "cm")))

      if(color_cells == "milestone") {
        plot <- plot +
          geom_point(color="black", data=milestone_positions, size=6) +
          geom_point(aes(color=color), data=milestone_positions %>% left_join(milestones, "milestone_id"), size=4)
      } else {
        plot <- plot +
          geom_point(color="#333333", data=milestone_positions, size=6, alpha=1)
      }
    }

    # add trajectory if requested
    if (plot_trajectory) {
      waypoint_projection <- project_waypoints(
        traj,
        cell_positions,
        trajectory_projection_sd=trajectory_projection_sd,
        n_arrows = n_arrows
      )

      milestone_positions <- waypoint_projection$positions %>%
        filter(!is.na(milestone_id))

      plot <- plot + geom_segment(
        aes(comp_1_from, comp_2_from, xend = comp_1_to, yend = comp_2_to),
        data=waypoint_projection$edges
      ) +
        geom_segment(
          aes(comp_1_from, comp_2_from, xend = comp_1_to, yend = comp_2_to),
          data=waypoint_projection$edges %>% filter(arrow),
          arrow = arrow(type="closed", length=(unit(0.1, "inches")))
        )
    }

    # add milestone labels
    # the positions of the milestones are calculated in the previous sections
    label_milestones <- get_milestone_labelling(traj, label_milestones)
    if((plot_trajectory || plot_milestone_network) && length(label_milestones)) {
      milestone_labels <- milestone_positions %>%
        mutate(label = label_milestones[milestone_id]) %>%
        filter(!is.na(label))

      plot <- plot + geom_label(aes(label=label), data=milestone_labels)
    }

    # add density labels
    if (!is.null(density_plots$labels))
      plot <- plot + density_plots$labels

    plot
  }
)
